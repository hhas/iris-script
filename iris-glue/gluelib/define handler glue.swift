//
//  handler glue.swift
//  gluelib
//
//

import Foundation
import iris

// TO DO: should stdlib be baked into libiris? or should it be built as a separate static/dynamic linked module?



// TO DO: operator syntax should eventually be expressible as patterns, e.g. `if condition:EXPR then action:EXPR (else alternative_action)?`

// TO DO: glue definitions could do with a `returns_self:true` property or `itself` return type for indicating a command should evaluate to itself; e.g. `foo returning bar` -> `foo returning bar`; currently stdlib glue manually defines `returning` as an operator, which is fine when used in a handler’s signature as `to` , but without an underlying command it will throw a not-found error if evaled (confusing to language explorers and useless for metaprogramming)

// TO DO: sort 'name' vs 'label' naming convention for all args+params

// TO DO: what about name/arg aliasing (including deprecated names)? (i.e. establishing a formal mechanism for amending an existing interface design enables automatic upgrading of user scripts)

// TO DO: what about introspecting the Swift func's API, e.g. to extract parameter names and primitive types, `throws`, and primitive return type? (also check for scope and coercion params); see: https://github.com/apple/swift-syntax

// TO DO: need `swift` coercion modifier to indicate where arguments/results should be bridged to Swift primitives (String, Array<T>, etc) rather than passed as native Values

// TO DO: would be helpful to validate swift function/binding names against list of known Swift keywords (and identifiers in Swift stdlib?) in order to reject/warn of any name conflicts

// TO DO: distinguish between swift_function, swift_struct, etc; this'll allow stub template to create appropriate skeleton (currently ElementRange stub renders as a func instead of struct+init)


var _handlerGlues = [HandlerGlue]()


// TO DO: glue definitions could be constructed by running the glue definition script with a custom Environment and custom/standard `to` handler, where evaluating the `to` operator's procedure operand populates a sub-scope that is a wrapper around/extension of HandlerGlue (for now we use a custom `to` handler that directly disassembles the procedure body, but this approach doesn't allow for metaprogramming); one caveat to evaluation strategy is that pair values need to be lazily evaluated - not entirely sure how to distinguish a command that returns the value to be used (e.g. when factoring out common information such as arithmetic operator definitions into a shared handler) from a command that is the value to be used (e.g. as in swift_function)


public struct HandlerGlue: Value {
    
    public var description: String { return "«HandlerGlue \(self.interface) \(self.canError), \(self.useScopes), \(String(describing: self.swiftFunction)), \(String(describing: self.operatorSyntax))»"}
    public static let nominalType: Coercion = AsComplex<HandlerGlue>(name: "HandlerGlue")
    
    // TO DO: also extract user documentation (from annotations); Q. where should user docs go? may be an idea to put them in separate data file that is loaded as needed (or just use the native glue def itself, assuming it isn't too slow to parse)
    typealias Parameter = (name: String, binding: String, coercion: String)
    
    typealias SwiftFunction = (name: String, params: [String])
    typealias OperatorSyntax = (form: String,
                                precedence: Int,
                                associate: PatternDefinition.Associativity,
                                keywords: [String],
                                reducefunc: String?) // TO DO: use [Keyword]
    
    let interface: HandlerInterface
    
    var name: String { return self.interface.name.label }
    var parameters: [Parameter] { return self.interface.parameters.map{($0.name.label, $0.binding.label, $0.coercion.swiftLiteralDescription)} }
    var result: String { return self.interface.result.swiftLiteralDescription } // coercion name
    
    let canError: Bool
    let useScopes: [String] // commandEnv, handlerEnv // TO DO: any use-cases for per-invocation sub-env?
    let swiftFunction: SwiftFunction? // if different to native names
    let operatorSyntax: OperatorSyntax?
}


// TO DO: this is replaced with record
typealias Options = [String: Value]


// performs full eval of right-side (e.g. `true`/`false` are commands which return corresponding Bool values, so either we eval them for can_error or else we unbox asCommand and use asIdentifier + switch to determine if true or false; right now we don't really care, but longer term we need to figure out how metaprogramming should behave, e.g. when distinguishing literal values from calculated [command-returned] values; on the one hand, glue definitions for e.g. arithmetic and comparison operators could themselves be generated by parameterizing the bits that change; on the other, that requires distinguishing between commands that should be evaled and commands that should be manipulated as-is [in kiwi this is trivial as tags provide orthogonal substitution mechanism which can be used within command names and args, but here commands do both so are not so easily rewritable])
func unpackOption<T: SwiftCoercion>(_ options: Options, _ name: String, in scope: Scope, as coercion: T) throws -> T.SwiftType {
    return try (options[name] ?? nullValue).swiftEval(in: scope, as: coercion)
}

func unboxOption<T: SwiftCoercion>(_ options: Options, _ name: String, in scope: Scope, as coercion: T) throws -> T.SwiftType {
    return try coercion.unbox(value: options[name] ?? nullValue, in: scope) // TO DO: slightly skeezy; we bypass swiftEval() as we don't want Command to look up handler (kludge it for now, but this is part of larger debate on double dispatch); nope, that doesn't work either as AsComplex calls swiftEval
}


let asOperatorSyntax = AsRecord([ // TO DO: given a native record/enum coercion, code generator should emit corresponding struct/enum definition and/or extension with static `unboxNativeValue()` method and primitive coercion // TO DO: rework this to allow patterns to be specified
    ("form", asSymbol),
    ("precedence", asInt),
    ("associate", AsSwiftDefault(asSymbol, defaultValue: "left")), // TO DO: need AsEnum(ofType,options)
    ("keywords", AsSwiftDefault(AsArray(asSymbol), defaultValue: [])),
    ("reducer", AsSwiftOptional(asSymbol))
    ])


func defineHandlerGlue(interface: HandlerInterface, attributes: Value, commandEnv: Scope, handlerEnv: Scope) throws {
  //  print("making glue for", interface)
    guard let handlerGlues = handlerEnv.get(handlerGluesName) as? OpaqueHandlerGlues else {
        throw UnknownNameError(name: handlerGluesName, in: handlerEnv)
    }
    guard let body = attributes as? Record else { // TO DO: glue currently uses asIs to pass record without any evaluation, leaving defineHandlerGlue to extract its fields below; eventually handler_glue record should be defined as a SwiftCoercion with named+typed fields, allowing it to unbox directly to HandlerGlue
        print("bad attributes (not record):", attributes)
        throw BadSyntax.missingExpression
    }
    let options = Options(uniqueKeysWithValues: body.fields.map{ ($0.key, $1) })
    let canError = try unpackOption(options, "can_error", in: commandEnv, as: AsSwiftDefault(asBool, defaultValue: false))
    let swiftFunction: HandlerGlue.SwiftFunction?
    if let cmd = try unboxOption(options, "swift_function", in: commandEnv, as: AsSwiftOptional(AsLiteral<Command>())) {
        // TO DO: if given, swiftfunc's parameter record should be of form `{label,…}` and/or `{label:binding,…}`
        // TO DO: error if no. of Swift params is neither 0 nor equal to no. of native params
        swiftFunction = (name: cmd.name.label, params: try cmd.arguments.map{
            guard let name = $0.value.asIdentifier() else { throw BadSyntax.missingName }
            return name.label
        })
    } else {
        swiftFunction = nil
    }
    let useScopes = try unpackOption(options, "use_scopes", in: commandEnv, as: AsSwiftDefault(AsArray(asSymbol), defaultValue: [])).map{"\($0.key)Env"}
    
    let operatorSyntax: HandlerGlue.OperatorSyntax?
    if let record = try unboxOption(options, "operator", in: commandEnv, as: AsOptional(asOperatorSyntax)) as? Record {
        let form = record.fields[0].value as! Symbol
        let precedence = try! asInt.unbox(value: record.fields[1].value, in: commandEnv) // native coercion may return Number
        let associativity: PatternDefinition.Associativity
        switch record.fields[2].value as! Symbol {
        case "left":
            associativity = .left
        case "right":
            associativity = .right
        default:
            print("malformed operator record", record)
            throw BadSyntax.missingExpression
        }
        let keywords = try! AsArray(asSymbol).unbox(value: record.fields[3].value, in: commandEnv).map{$0.key} // TO DO: what type?
        let reducefunc = try! AsSwiftOptional(asSymbol).unbox(value: record.fields[4].value, in: commandEnv)?.label
        operatorSyntax = (form.key, precedence, associativity, keywords, reducefunc)
    } else {
        operatorSyntax = nil
    }
    handlerGlues.data.append(HandlerGlue(interface: interface, canError: canError, useScopes: useScopes,
                                         swiftFunction: swiftFunction, operatorSyntax: operatorSyntax))
}


