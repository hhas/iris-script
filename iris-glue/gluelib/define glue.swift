//
//  handler glue.swift
//  gluelib
//
//

import Foundation
import iris

// TO DO: should stdlib be baked into libiris? or should it be built as a separate static/dynamic linked module?



// TO DO: operator syntax should eventually be expressible as patterns, e.g. `if condition:EXPR then action:EXPR (else alternative_action)?`

// TO DO: glue definitions could do with a `returns_self:true` property or `itself` return type for indicating a command should evaluate to itself; e.g. `foo returning bar` -> `foo returning bar`; currently stdlib glue manually defines `returning` as an operator, which is fine when used in a handler’s signature as `to` , but without an underlying command it will throw a not-found error if evaled (confusing to language explorers and useless for metaprogramming)

// TO DO: sort 'name' vs 'label' naming convention for all args+params

// TO DO: what about name/arg aliasing (including deprecated names)? (i.e. establishing a formal mechanism for amending an existing interface design enables automatic upgrading of user scripts)

// TO DO: what about introspecting the Swift func's API, e.g. to extract parameter names and primitive types, `throws`, and primitive return type? (also check for scope and coercion params); see: https://github.com/apple/swift-syntax

// TO DO: need `swift` coercion modifier to indicate where arguments/results should be bridged to Swift primitives (String, Array<T>, etc) rather than passed as native Values

// TO DO: would be helpful to validate swift function/binding names against list of known Swift keywords (and identifiers in Swift stdlib?) in order to reject/warn of any name conflicts

// TO DO: distinguish between swift_function, swift_struct, etc; this'll allow stub template to create appropriate skeleton (currently ElementRange stub renders as a func instead of struct+init)


// TO DO: glue definitions could be constructed by running the glue definition script with a custom Environment and custom/standard `to` handler, where evaluating the `to` operator's procedure operand populates a sub-scope that is a wrapper around/extension of HandlerGlue (for now we use a custom `to` handler that directly disassembles the procedure body, but this approach doesn't allow for metaprogramming); one caveat to evaluation strategy is that pair values need to be lazily evaluated - not entirely sure how to distinguish a command that returns the value to be used (e.g. when factoring out common information such as arithmetic operator definitions into a shared handler) from a command that is the value to be used (e.g. as in swift_function)

// TO DO: this is replaced with record
typealias Options = [String: Value]


// performs full eval of right-side (e.g. `true`/`false` are commands which return corresponding Bool values, so either we eval them for can_error or else we unbox asCommand and use asIdentifier + switch to determine if true or false; right now we don't really care, but longer term we need to figure out how metaprogramming should behave, e.g. when distinguishing literal values from calculated [command-returned] values; on the one hand, glue definitions for e.g. arithmetic and comparison operators could themselves be generated by parameterizing the bits that change; on the other, that requires distinguishing between commands that should be evaled and commands that should be manipulated as-is [in kiwi this is trivial as tags provide orthogonal substitution mechanism which can be used within command names and args, but here commands do both so are not so easily rewritable])
func unpackOption<T: SwiftCoercion>(_ options: Options, _ name: String, in scope: Scope, as coercion: T) throws -> T.SwiftType {
    return try (options[name] ?? nullValue).swiftEval(in: scope, as: coercion)
}

func unboxOption<T: SwiftCoercion>(_ options: Options, _ name: String, in scope: Scope, as coercion: T) throws -> T.SwiftType {
    return try coercion.unbox(value: options[name] ?? nullValue, in: scope) // TO DO: slightly skeezy; we bypass swiftEval() as we don't want Command to look up handler (kludge it for now, but this is part of larger debate on double dispatch); nope, that doesn't work either as AsComplex calls swiftEval
}

let asPatternValues = AsArray(asPatternValue)

let asOperatorSyntax = AsRecord([ // TO DO: given a native record/enum coercion, code generator should emit corresponding struct/enum definition and/or extension with static `unboxNativeValue()` method and primitive coercion // TO DO: rework this to allow patterns to be specified
    ("pattern", asPatternValues),
    ("precedence", asInt),
    ("associate", AsSwiftDefault(asSymbol, default: "left")), // TO DO: need AsEnum(ofType,options)
    ("reducer", AsSwiftOptional(asSymbol))
    ])




func defineHandlerGlue(interface: HandlerInterface, attributes: Value, commandEnv: Scope, handlerEnv: Scope) throws {
    print("Making glue for:", interface)
    guard let handlerGlues = handlerEnv.get(handlerGluesKey) as? OpaqueHandlerGlues else {
        throw UnknownNameError(name: handlerGluesKey, in: handlerEnv)
    }
    guard let body = attributes as? Record else { // TO DO: glue currently uses asIs to pass record without any evaluation, leaving defineHandlerGlue to extract its fields below; eventually handler_glue record should be defined as a SwiftCoercion with named+typed fields, allowing it to unbox directly to HandlerGlue
        print("bad attributes (not record):", attributes)
        throw BadSyntax.missingExpression
    }
    let options = Options(uniqueKeysWithValues: body.data.map{ ($0.key, $1) })
    let canError = try unpackOption(options, "can_error", in: commandEnv, as: AsSwiftDefault(asBool, default: false))
    let swiftFunction: HandlerGlue.SwiftFunction?
    if let cmd = try unboxOption(options, "swift_function", in: commandEnv, as: AsSwiftOptional(AsLiteral<Command>())) {
        // TO DO: if given, swiftfunc's parameter record should be of form `{label,…}` and/or `{label:binding,…}`
        // TO DO: error if no. of Swift params is neither 0 nor equal to no. of native params
        swiftFunction = (name: cmd.name.label, params: try cmd.arguments.map{
            guard let name = $0.value.asIdentifier() else { throw BadSyntax.missingName }
            return name.label
        })
    } else {
        swiftFunction = nil
    }
    let useScopes = try unpackOption(options, "use_scopes", in: commandEnv, as: AsSwiftDefault(AsArray(asSymbol), default: [])).map{"\($0.key)Env"}
    
    let operatorSyntax: HandlerGlue.OperatorSyntax?
    if let record = try unboxOption(options, "operator", in: commandEnv, as: AsOptional(asOperatorSyntax)) as? Record {
        operatorSyntax = try unpackOperatorDefinition(record, in: commandEnv)
    } else {
        operatorSyntax = nil
    }
    let name = interface.name
    if handlerGlues.data[name] == nil {
        handlerGlues.data[name] = HandlerGlue(interface: interface, canError: canError, useScopes: useScopes,
                                              swiftFunction: swiftFunction, operatorSyntax: operatorSyntax)
    } else {
        print("Error: ignoring duplicate definition for: \(interface)")
    }
}

func unpackOperatorDefinition(_ record: Record, in commandEnv: Scope) throws -> HandlerGlue.OperatorSyntax {
    let patterns = try! asPatternValues.unbox(value: record.data[0].value, in: commandEnv).map{$0.data}
    let patternSeq: [iris.Pattern]
    if patterns.count == 1, case .sequence(let seq) = patterns[0] {
        patternSeq = seq
    } else {
        patternSeq = patterns
    }
    let precedence = try! asInt.unbox(value: record.data[1].value, in: commandEnv) // native coercion may return Number
    let associativity: Associativity
    switch record.data[2].value as! Symbol {
    case "left":
        associativity = .left
    case "right":
        associativity = .right
    default:
        print("malformed operator record", record)
        throw BadSyntax.missingExpression
    }
    let reducefunc = try! AsSwiftOptional(asSymbol).unbox(value: record.data[3].value, in: commandEnv)!.label
    return (patternSeq, precedence, associativity, reducefunc)

}


