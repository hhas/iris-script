//
//  optional constraints.swift
//  libiris
//

// TO DO: constraint support for native coercions should be defined by extension; eventually these extensions will be code-generated by `iris-glue`, which should also generate the environment bindings that load them (for now, Environment.define(coercion:) does an extra type check)

import Foundation



extension AsOptional: ConstrainableCoercion {
    
    public var interface: HandlerInterface { return AsOptional.interface_constrain }
    
    private static let type_constrain = (
        name: Symbol("optional"),
        param_0: (Symbol("of_type"), Symbol("value_type"), AsSwiftDefault(asCoercion, asValue)),
        param_1: (Symbol("with_default"), Symbol("default_value"), asAnything),
        result: asCoercion
    )
    
    private static let interface_constrain = HandlerInterface(
        name: type_constrain.name,
        parameters: [
            nativeParameter(type_constrain.param_0),
            nativeParameter(type_constrain.param_1),
        ],
        result: type_constrain.result.nativeCoercion
    )
    
    public func constrain(to command: Command, in scope: Scope) throws -> NativeCoercion {
        var index = 0
        let arg_0 = try command.value(for: AsOptional.type_constrain.param_0, at: &index, in: scope)
        let arg_1 = try command.value(for: AsOptional.type_constrain.param_1, at: &index, in: scope)
        if command.arguments.count > index { throw UnknownArgumentError(at: index, of: command, to: self) }
        return AsOptional(arg_0, defaultValue: arg_1)
    }
}

