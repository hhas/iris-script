
«= stdlib glue definition =»

«== Arithmetic operators ==»

«TODO: should symbolic operators have word-based aliases? (these would provide speakable support automatically; alternative is to match spoken phrases to the symbols’ Unicode names)»

«TODO: should `&` have higher precedence than command? e.g. `uppercase "Hello," & name`»


to ‘^’ {left as number, right as number} returning number requires {
    can_error: true
    swift_function: exponent
    operator: {[expr, keyword [“^”, “to_the_power_of”], expr], precedence: 1300, associate: #right, #reductionForInfixOperator}
}


«TO DO: unary positive/negative should be defined as ‘+’ and ‘-’ (primary names), and loaded into env as multimethods that dispatch on argument fields (for now, we define "+"/"-" as secondary alias names)»

«TO DO: what about plain text names (“add”, “subtract”, “multiply”, etc)? what about speakable names, e.g. “plus”, “minus”, “multiplied_by”? defining as aliases pollutes the global namespace; OTOH, these names are probably specific enough that they won’t often collide with scripts’ own namings»


«TO DO: rename these ‘+’ and ‘-’ once handler overloading [matching argument labels] is implemented; i.e. canonical names will appear in pretty printed code»

to ‘positive’ {right as number} returning number requires {
    can_error: true
    swift_function: positive
    operator: {[keyword [“positive”, “+”, 0uFF0B], expr "right"], precedence: 1298, #left, #reductionForPositiveOperator}
}

to ‘negative’ {right as number} returning number requires {
    can_error: true
    swift_function: negative
    operator: {[keyword [“negative”, “-”, 0uFF0D, 0u2212, 0uFE63], expr "right"], precedence: 1298, #left, #reductionForNegativeOperator}
}


to ‘*’ {left as number, right as number} returning number requires {
    can_error: true
    swift_function: multiply
    operator: {infix [“*”, “×”], precedence: 1296, #left, #reductionForInfixOperator}
}

to ‘/’ {left as number, right as number} returning number requires {
    can_error: true
    swift_function: divide
    operator: {infix [“/”, “÷”], precedence: 1296, #left, #reductionForInfixOperator}
}

to ‘div’ {left as real, right as real} returning real requires {
    can_error: true
    operator: {infix [“div”], precedence: 1296, #left, #reductionForInfixOperator}
}

to ‘mod’ {left as real, right as real} returning real requires {
    can_error: true
    operator: {infix [“mod”], precedence: 1296, #left, #reductionForInfixOperator}
}



to ‘+’ {left as Number, right as Number} returning Number requires {
    can_error: true
    swift_function: add
    operator: {infix [“+”, 0uFF0B], precedence: 1290, #left, #reductionForInfixOperator}
}

to ‘-’ {left as Number, right as Number} returning Number requires {
    can_error: true
    swift_function: subtract
    operator: {infix [“-”, 0uFF0D, 0u2212, 0uFE63], precedence: 1290, #left, #reductionForInfixOperator}
}



to ‘<’ {left as real, right as real} returning boolean requires {
    swift_function: isLess
    operator: {infix [“<”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘≤’ {left as real, right as real} returning boolean requires {
    swift_function: isLessOrEqual
    operator: {infix [“≤”, “<=”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘=’ {left as real, right as real} returning boolean requires {  «equality test, c.f. APL»
    swift_function: isEqual
    operator: {infix [“=”, “==”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘≠’ {left as real, right as real} returning boolean requires {
    swift_function: isNotEqual
    operator: {infix [“≠”, “<>”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘>’ {left as real, right as real} returning boolean requires {
    swift_function: isGreater
    operator: {infix [“>”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘≥’ {left as real, right as real} returning boolean requires {
    swift_function: isGreaterOrEqual
    operator: {infix [“≥”, “>=”], precedence: 540, #left, #reductionForInfixOperator}
}


«== Boolean operators ==»

to ‘NOT’ {right as boolean} returning boolean requires {
    operator: {prefix [“NOT”], precedence: 400, #left, #reductionForPrefixOperator}
}

to ‘AND’ {left as boolean, right as boolean} returning boolean requires {
    operator: {infix [“AND”], precedence: 398, #left, #reductionForInfixOperator}
}

to ‘OR’ {left as boolean, right as boolean} returning boolean requires {
    operator: {infix [“OR”], precedence: 396, #left, #reductionForInfixOperator}

}

to ‘XOR’ {left as boolean, right as boolean} returning boolean requires {
    operator: {infix [“XOR”], precedence: 394, #left, #reductionForInfixOperator}
}


«== String operators ==»

«note: comparisons may throw if/when trinary `as` clause is added [unless we build extra smarts into glue generator to apply that coercion to the other args automatically, in which case glue code with throw so primitive funcs don’t have to]»

«Q. how to name these operators? ideally they should not be confused with arithmetical comparison operators when spoken»

«=== comparison operators ===»

to ‘is_before’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“is_before”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘is_not_after’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“is_not_after”, “is_before_or_same_as”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘is_same_as’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“is_same_as”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘is_not_same_as’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“is_not_same_as”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘is_after’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“is_after”], precedence: 540, #left, #reductionForInfixOperator}
}

to ‘is_not_before’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“is_not_before”, “is_same_as_or_after”], precedence: 540, #left, #reductionForInfixOperator}
}

«=== containment operators ===»

«TO DO: convenience `does_not_begin_with`, etc.»

to ‘begins_with’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“begins_with”], precedence: 542, #left, #reductionForInfixOperator}
}

to ‘ends_with’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“ends_with”], precedence: 542, #left, #reductionForInfixOperator}
}

to ‘contains’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“contains”], precedence: 542, #left, #reductionForInfixOperator}
}

to ‘is_in’ {left as string, right as string} returning boolean requires {
    can_error: true
    operator: {infix [“is_in”], precedence: 542, #left, #reductionForInfixOperator}
}

«=== other operators ===»

to ‘&’ {left as string, right as string} returning string requires {
    can_error: true
    swift_function: joinValues
    operator: {infix [“&”], precedence: 340, #left, #reductionForInfixOperator}
}


«== String commands ==»

to uppercase {text as string} returning string requires {
}

to lowercase {text as string} returning string requires {
}

to format_code {value as optional} returning string requires {
}


«== IO commands ==»

to write {value as anything} returning nothing requires {
«TODO: ‘to’ argument field for specifying the external resource to write to (for now, primitive func is hardcoded to print() value’s description to stdout)»
«TODO: what about error handling? e.g. if writing to locked/missing file; we want to keep read and write commands as generic as possible; OTOH, not all writers will throw [e.g. Swift’s standard print() never throws]»
}


«== Type operators ==»

to ‘is_a’ {value as anything, coercion as coercion} returning boolean requires {
    use_scopes: #command
    operator: {infix [“is_a”], 540, #left, #reductionForInfixOperator}
}

to ‘as’ {value as anything, coercion as coercion} returning anything requires {
    can_error: true
    use_scopes: #command
    swift_function: coerce
    operator: {infix [“as”], 350, #left, #reductionForInfixOperator}
}


«== Flow control ==»

«TODO: better labels than left/right»

to ‘to’ {interface as handler_interface, action as expression} returning procedure requires {
    can_error: true
    use_scopes: #command
    swift_function: defineCommandHandler {interface, action}
    operator: {[keyword “to”, expr “interface”, keyword “run”, expr “action”], 80, #left, #reductionForPrefixOperatorWithConjunction}
}

to ‘when’ {interface as handler_interface, action as expression} returning procedure requires {
    can_error: true
    use_scopes: #command
    swift_function: defineEventHandler {interface, action}
    operator: {[keyword “when”, expr “interface”, keyword “run”, expr “action”], 80, #left, #reductionForPrefixOperatorWithConjunction}
}

to ‘set’ {name as name, to: value as anything} returning anything requires { «assignment; TODO: ‘name’ argument should be name or chunk expression»
    can_error: true
    use_scopes: #command
    operator: {[keyword “set”, expr “name”, keyword “to”, expr “value”], 80, #left, #reductionForInfixOperator}
}

to ‘if’ {test: condition as boolean, then: action as expression, else: alternative_action as expression} returning anything requires {
    can_error: true «TODO: would be better to distinguish errors thrown by arguments from errors thrown by handler itself»
    use_scopes: #command
    swift_function: ifTest {condition, action, alternativeAction}
    operator: {[keyword “if”, expr “condition”,
    							keyword “then”, expr “action”,
    							option sequence [keyword “else”, expr “alternative_action”]], 101, #left, #reductionForPrefixOperatorWithConjunctionAndAlternate}
}

«TODO: how to express return type? e.g. `returning result of action`?»
to ‘while’ {condition as boolean, action as expression} returning anything requires {
    can_error: true
    use_scopes: #command
    swift_function: whileRepeat {condition, action}
    operator: {[keyword “while”, expr “condition”, keyword “repeat”, expr “action”], 101, #left, #reductionForPrefixOperatorWithConjunction}
}

to ‘repeat’ {action as expression, condition as boolean} returning anything requires {
    can_error: true
    use_scopes: #command
    swift_function: repeatWhile {action, condition}
    operator: {[keyword “repeat”, expr “condition”, keyword “while”, expr “action”], 101, #left, #reductionForPrefixOperatorWithConjunction}
}

to ‘tell’ {target as value, action as expression} returning anything requires {
    can_error: true
    use_scopes: #command
    swift_function: tell {target, action}
    operator: {[keyword “tell”, expr “target”, keyword “to”, expr “action”], 101, #left, #reductionForPrefixOperatorWithConjunction}
}


«== Chunk expressions ==»

to ‘of’ {attribute as expression, value as value} returning expression requires { «TODO: is left operand always a command?»
    can_error: true «TODO: throw immediately, or wait until query if fully constructed?»
    use_scopes: [#command, #handler]
    swift_function: ofClause {attribute, target}
    operator: {infix “of”, 1100, #right, #reductionForInfixOperator} «binds tighter than commands»
}


to ‘app’ {bundle_identifier as string} returning value requires {
    can_error: true «TODO: errors (e.g. app not found) should only occur upon use, not creation»
    swift_function: Application
}


«=== Element selectors ===»

to ‘at’ {element_type as name, selector_data as expression} returning expression requires {
    can_error: true
    use_scopes: [#command, #handler] «`elements at expr thru expr` will eval exprs in handler’s scope, delegating to command scope»
    swift_function: atSelector {elementType, selectorData}
    operator: {infix [“at”, “index”], 1110, #right, #reductionForInfixOperator}
}

to ‘named’ {element_type as name, selector_data as expression} returning expression requires {
    can_error: true
    use_scopes: #command
    swift_function: nameSelector {elementType, selectorData}
    operator: {infix “named”, 1110, #right, #reductionForInfixOperator}
}

to ‘id’ {element_type as name, selector_data as expression} returning expression requires { «TODO: what about ‘id’ properties? (easiest is to define id as .atom operator as well as .infix, with multimethod despatching on 0/2 operands; while operators could in principle fall back to commands when the operands found don’t match any of the known operator definitions, it would be hard to distinguish an intended command from an operator with missing arguments [i.e. syntax error])»
    can_error: true
    use_scopes: #command
    swift_function: idSelector {elementType, selectorData}
    operator: {infix “id”, 1110, #right, #reductionForInfixOperator}
}

to ‘from’ {element_type as name, selector_data as expression} returning expression requires { «TO DO: use `at` for both index and range specifiers?»
    can_error: true
    use_scopes: [#command, #handler]
    swift_function: rangeSelector {elementType, selectorData}
    operator: {infix “from”, 1110, #right, #reductionForInfixOperator}
}

to ‘whose’ {element_type as name, selector_data as expression} returning expression requires {
    can_error: true
    use_scopes: [#command, #handler] «`elements where expr` will eval expr in handler’s scope, delegating to command scope, allowing expr to refer to properties and elements without requiring an explicit `its`»
    swift_function: testSelector {elementType, selectorData}
    operator: {infix [“whose”, “where”], 1110, #right, #reductionForInfixOperator}
}

«=== element range ===»

to ‘thru’ {start_selector as expression, stop_selector as expression} returning expression requires {
    swift_function: ElementRange {‘from’, ‘to’}
    operator: {infix [“thru”, “through”], 1120, #right, #reductionForInfixOperator}
}

«=== absolute ordinal ===»

to ‘first’ {element_type as name} returning expression requires {
    swift_function: firstElement
    operator: {prefix “first”, precedence: 1130, #right, #reductionForPrefixOperator}
}

to ‘middle’ {element_type as name} returning expression requires {
    swift_function: middleElement
    operator: {prefix “middle”, precedence: 1130, #right, #reductionForPrefixOperator}
}

to ‘last’ {element_type as name} returning expression requires {
    swift_function: lastElement
    operator: {prefix “last”, precedence: 1130, #right, #reductionForPrefixOperator}
}

to ‘any’ {element_type as name} returning expression requires { «TODO: what to call this? ‘any’? ‘some’? ‘random’?»
    swift_function: randomElement
    operator: {prefix [“any”, “some”], precedence: 1130, #right, #reductionForPrefixOperator}
}

to ‘every’ {element_type as name} returning expression requires {
    swift_function: allElements
    operator: {prefix [“every”, “all”], precedence: 1130, #right, #reductionForPrefixOperator}
}

«=== relative ordinal ===»

to ‘before’ {element_type as name, expression as expression} returning expression requires {
    swift_function: beforeElement
    operator: {infix [“before”], precedence: 1126, #right, #reductionForInfixOperator}
}

to ‘after’ {element_type as name, expression as expression} returning expression requires {
    swift_function: afterElement
    operator: {infix [“after”], precedence: 1126, #right, #reductionForInfixOperator}
}

«=== insertion location ====»

to ‘before’ {expression as expression} returning expression requires {
    swift_function: insertBefore
    operator: {prefix [“before”], precedence: 1106, #right, #reductionForAtomOperator}
}

to ‘after’ {expression as expression} returning expression requires {
    swift_function: insertAfter
    operator: {prefix [“after”], precedence: 1106, #right, #reductionForAtomOperator}
}

to ‘beginning’ returning expression requires {
    swift_function: insertAtBeginning
    operator: {atom [“beginning”], precedence: 1106, #right, #reductionForAtomOperator}
}

to ‘end’ returning expression requires {
    swift_function: insertAtEnd
    operator: {atom [“end”], precedence: 1106, #right, #reductionForAtomOperator}
}
