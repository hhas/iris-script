//
//  handler glue.swift
//  gluelib
//
//

import Foundation

// TO DO: sort 'name' vs 'label' naming convention for all args+params


var _handlerGlues = [HandlerGlue]()



struct HandlerGlue: Value {
    
    var description: String { return "«HandlerGlue»"}
    let nominalType: Coercion = AsComplex<HandlerGlue>(name: "HandlerGlue")
    
    // TO DO: also extract user documentation (from annotations); Q. where should user docs go? may be an idea to put them in separate data file that is loaded as needed (or just use the native glue def itself, assuming it isn't too slow to parse)
    typealias Parameter = (name: String, binding: String, coercion: String)
    
    typealias SwiftFunction = (name: String, params: [String])
    typealias OperatorSyntax = (form: String, precedence: Int, isLeftAssociative: Bool, aliases: [String])
    
    let interface: HandlerInterface
    
    var name: String { return self.interface.name.label }
    var parameters: [Parameter] { return self.interface.parameters.map{($0.name.label, $0.binding.label, $0.coercion.swiftCode)} }
    var result: String { return self.interface.result.swiftCode } // coercion name
    
    let canError: Bool
    let useScopes: [String] // commandEnv, handlerEnv // TO DO: any use-cases for per-invocation sub-env?
    let swiftFunction: SwiftFunction? // if different to native names
    let operatorSyntax: OperatorSyntax?
}

typealias Options = [String: Value]

func readOptions(_ block: Block, _ result: inout Options) throws {
    for option in block.data {
        switch option {
        case let block as Block:
            try readOptions(block, &result)
        case let pair as Pair:
            guard let name = pair.key.asIdentifier() else {throw BadSyntax.missingExpression}
            result[name.key] = pair.value
        default:
            throw BadSyntax.missingExpression
        }
    }
}

// performs full eval of right-side (e.g. `true`/`false` are commands which return corresponding Bool values, so either we eval them for can_error or else we unbox asCommand and use asIdentifier + switch to determine if true or false; right now we don't really care, but longer term we need to figure out how metaprogramming should behave, e.g. when distinguishing literal values from calculated [command-returned] values; on the one hand, glue definitions for e.g. arithmetic and comparison operators could themselves be generated by parameterizing the bits that change; on the other, that requires distinguishing between commands that should be evaled and commands that should be manipulated as-is [in kiwi this is trivial as tags provide orthogonal substitution mechanism which can be used within command names and args, but here commands do both so are not so easily rewritable])
func unpackOption<T: SwiftCoercion>(_ options: Options, _ name: String, in scope: Scope, as coercion: T) throws -> T.SwiftType {
    return try (options[name] ?? nullValue).swiftEval(in: scope, as: coercion)
}

func unboxOption<T: SwiftCoercion>(_ options: Options, _ name: String, in scope: Scope, as coercion: T) throws -> T.SwiftType {
    return try coercion.unbox(value: options[name] ?? nullValue, in: scope) // TO DO: slightly skeezy; we bypass swiftEval() as we don't want Command to look up handler (kludge it for now, but this is part of larger debate on double dispatch); nope, that doesn't work either as AsComplex calls swiftEval
}

func defineHandlerGlue(handler: Handler, commandEnv: Scope) throws {
    //print("making glue for", handler)
    //print(glue)
    guard let body = (handler as! NativeHandler).action as? Block else { throw BadSyntax.missingExpression }
    var options = Options()
    try readOptions(body, &options)
    
    let canError = try unpackOption(options, "can_error", in: commandEnv, as: AsSwiftDefault(asBool, defaultValue: false))
    let swiftFunction: HandlerGlue.SwiftFunction?
    // TO DO: decide syntax for swift_function (name + parens syntax won't work without parser extension; probably simpler to use native syntax, but should Swift argument labels be given as labels or as values, e.g. `add{left,right}` vs `add{left:…,right:…}`)?
    if let cmd = try unboxOption(options, "swift_function", in: commandEnv, as: AsSwiftOptional(asCommand)) {
        swiftFunction = (name: cmd.name.label, params: try cmd.arguments.map{
            guard let name = $0.value.asIdentifier() else { throw BadSyntax.missingName }
            return name.label
        })
    } else {
        swiftFunction = nil
    }
    // TO DO: operators
    
    let glue = HandlerGlue(interface: handler.interface, canError: canError, useScopes: [], swiftFunction: swiftFunction, operatorSyntax: nil)
    
    //print(glue)
    
    _handlerGlues.append(glue) // ideally should append glues to editable list stored in commandEnv (or use an Environment subclass that captures glues directly, or pass collector array to defineHandlerGlue as an ExternalResource, but for now just chuck them all in a global and run renderer on that)

}


/*
let libraryName = "stdlib"

let handlerGlues = [
    HandlerGlue(name: "add", parameters: [("left", "AsNumber()"), ("right", "AsNumber()")], result: "AsNumber()", canError: true, useScopes: [], swiftFunction: nil, operatorSyntax: (form: "+", precedence: 560, isLeftAssociative: false, aliases: [])),
    HandlerGlue(name: "subtract", parameters: [("left", "AsNumber()"), ("right", "AsNumber()")], result: "AsNumber()", canError: true, useScopes: [], swiftFunction: nil, operatorSyntax: (form: "-", precedence: 560, isLeftAssociative: false, aliases: [])),]
*/
//print(template.render())



func renderGlue(libraryName: String, handlerGlues: [HandlerGlue]) -> String {
    return handlersTemplate.render((libraryName, handlerGlues))
}


//print(handlersTemplate.debugDescription)
//print(source)




func renderHandlerGlue(for libraryName: String, from script: String) throws -> String {
    
    // glue definition for primitive handler
    
    // TO DO: what about name/arg aliasing (including deprecated names)? (i.e. establishing a formal mechanism for amending an existing interface design enables automatic upgrading of user scripts)
    
    // TO DO: what about introspecting the Swift func's API, e.g. to extract parameter names and primitive types, `throws`, and primitive return type?
    
    // TO DO: need `swift` coercion modifier to indicate where arguments/results should be bridged to Swift primitives (String, Array<T>, etc) rather than passed as native Values
    
    let env = Environment()
    gluelib_loadHandlers(into: env)
    stdlib_loadConstants(into: env)
    
    let operatorRegistry = OperatorRegistry()
    stdlib_loadOperators(into: operatorRegistry)
    let operatorReader = newOperatorReader(for: operatorRegistry)
    
    let doc = EditableScript(script) { NumericReader(operatorReader(NameReader(UnicodeReader($0)))) }
    let p = Parser(tokenStream: QuoteReader(doc.tokenStream), operatorRegistry: operatorRegistry)
    do {
        let script = try p.parseScript()
        //print(script)
        let _ = (try script.eval(in: env, as: asAnything))
        let code = renderGlue(libraryName: libraryName, handlerGlues: _handlerGlues)
        return(code)
    } catch {
        print(error)
        throw error
    }
}

